defmodule BrettProjekt.Game do
  alias BrettProjekt.Game.Player, as: Player

  @enforce_keys [:game_id, :question_server]
  defstruct [
    :game_id,
    {:mode, :lobby},
    {:round, 0},
    {:rounds, []},
    {:id_count, 0},
    {:players, %{}},
    {:join_enabled, true},
    :question_server
  ]

  # ---------- CLIENT API ----------
  @doc """
  Creates a new game with id.

  ## Parameters

    - game_id: a unique identifier of the game. Normally generated by the game manager.

  ## Examples

      BrettProjekt.Game.create System.unique_integer

  """
  def create(game_id, question_server) do
    GenServer.start_link(BrettProjekt.GameServer,
                         %BrettProjekt.Game{game_id: game_id,
                                            question_server: question_server})
  end

  @doc """
  Returns the unique game-id set when calling `create/1`
  """
  def get_id(game) do
    GenServer.call(game, :get_id)
  end

  defp name_valid?(name) do
    cond do
      is_binary(name) == false -> false
      String.printable?(name) == false -> false
      String.length(name) < 3 -> false
      String.length(name) > 12 -> false
      true -> true
    end
  end

  @doc """
  Add a new player with a given name to the game.

  The player name will be trimmed and converted to lowercase.

  ## Arguments

    - game: The game to which the player is going to be added
    - name: The name of the new player

  """
  def add_new_player(game, name) do
    name = String.downcase String.trim name
    cond do
      name_valid?(name) == false ->
        {:error, :name_invalid}

      join_enabled?(game) == false ->
        {:error, :joining_disabled}

      has_player?(game, name) == true ->
        {:error, :name_conflict}

      true ->
        roles =
          case Enum.count get_players(game) do
            0 -> [:admin]
            _ -> []
          end

        player_id = GenServer.call game, :get_new_player_id
        {:ok, player} = Player.create player_id, name, roles

        GenServer.call(game, {:add_player, player})
    end
  end

  @doc """
  Returns a map of players with the player-id as key and a player-struct as the value.
  """
  def get_players(game) do
    GenServer.call(game, :get_players)
  end

  @doc """
  Returns whether a game can be joined by a new player

  ## Parameters

    - game: The game to check on

  ## Examples

      iex> {:ok, game} = BrettProjekt.Game.create System.unique_integer # Should be generated by the GameManager
      iex> BrettProjekt.Game.join_enabled? game
      true
      iex> BrettProjekt.Game.disable_join game
      iex> BrettProjekt.Game.join_enabled? game
      false

  """
  def join_enabled?(game) do
    GenServer.call game, :get_join_enabled
  end

  @doc """
  Disables joining of new players

  ## Arguments

    - game: The game on which joining of new players should be disabled

  """
  def disable_join(game) do
    GenServer.call game, :disable_join
  end

  @doc """
  Checks if a player with name is in the game

  The name that will be checked gets trimmed and converted to lowercase.

  ## Arguments

    - game: The game to check for players
    - player_name: Name of the player to search for

  """
  def has_player?(game, player_name) do
    player = Enum.find(get_players(game), fn({_player_id, player}) ->
      name = Player.get_name player
      player_name = String.downcase String.trim player_name
      name == player_name
    end)

    case player do
      nil -> false
      _ -> true
    end
  end

  def get_player(game, player_id) do
    Enum.find(get_players(game), fn({id, _player}) -> id == player_id end)
  end

  @doc """
  Check whether the game is startable.

  The game can only be started, if every player is assigned to a team and
  there are at least two teams with players assigned to them.
  """
  def startable?(game) do
    # Check if every player is in a team
    players_without_team =
      Enum.filter(get_players(game), fn ({id, player}) ->
        Player.get_team(player) == nil end)

    # Check if at least two teams have players in them
    teams_with_players =
      Enum.reduce(get_players(game), MapSet.new, fn({id, player}, acc) ->
        case Player.get_team(player) do
          nil  -> acc
          team -> MapSet.put acc, team
        end
      end)

    cond do
      length(players_without_team) > 0 -> false
      length(teams_with_players) < 2   -> false
      true                             -> true
    end
  end

  def start(game) do
    GenServer.call(game, {:set_mode, :round_preparation})
    initialize_round game
  end

  def game_started?(game) do
    GenServer.call(game, :get_mode) != :lobby
  end

  def initialize_round(game) do
    # Randomly generate a list of question-lists per team
    # Each question-list has 3 questions of different categories and each team
    # has questions of the same categories
    true
  end

  def round_started?(_game) do
    false  # TODO
  end

  def get_categories(game) do
    GenServer.call game, :get_categories
  end

  def set_player_categories(game, player, categories) do
    categories_available =
      game
      |> get_categories
      |> MapSet.new
      |> (&MapSet.subset?(MapSet.new(categories), &1)).()

    GenServer.call game, {:set_player_categories, player, categories}

    unless categories_available do
      {:error, :categories_unavailable}
    else
      :ok
    end
  end

  def get_player_categories(game, player) do
    # TODO
  end
end
